"""Wrappers for Drake/ContactNets multibody experiments."""
from abc import ABC
from dataclasses import field, dataclass
from enum import Enum
from typing import Optional, cast, Dict

import torch
from torch import Tensor

from dair_pll import file_utils
from dair_pll import vis_utils
from dair_pll.deep_learnable_system import DeepLearnableExperiment
from dair_pll.drake_system import DrakeSystem
from dair_pll.experiment import SupervisedLearningExperiment, \
    LEARNED_SYSTEM_NAME, PREDICTION_NAME, TARGET_NAME
from dair_pll.experiment_config import SystemConfig, \
    SupervisedLearningExperimentConfig
from dair_pll.multibody_learnable_system import \
    MultibodyLearnableSystem
from dair_pll.system import System, SystemSummary


@dataclass
class DrakeSystemConfig(SystemConfig):
    urdfs: Dict[str, str] = field(default_factory=dict)


class MultibodyLosses(Enum):
    PREDICTION_LOSS = 1
    CONTACTNETS_LOSS = 2
    VISION_LOSS = 3


@dataclass
class MultibodyLearnableSystemConfig(DrakeSystemConfig):
    loss: MultibodyLosses = MultibodyLosses.PREDICTION_LOSS
    """Whether to use ContactNets or prediction loss."""
    pretrained_icnn_weights_filepath: str = None
    """If provided, filepath to pretrained ICNN weights."""
    learn_inertia: str = 'all'
    """Which inertia parameters to learn in the system ('all' excludes mass)."""
    w_pred: float = 1.0
    """Weight of prediction term in ContactNets loss (suggested keep at 1.0)."""
    w_comp: float = 1.0
    """Weight of complementarity term in ContactNets loss."""
    w_diss: float = 1.0
    """Weight of dissipation term in ContactNets loss."""
    w_pen: float = 20.0
    """Weight of penetration term in ContactNets loss."""
    w_bsdf: float = 1.0
    """Weight of BundleSDF matching term in vision experiment loss."""


@dataclass
class DrakeMultibodyLearnableExperimentConfig(SupervisedLearningExperimentConfig
                                             ):
    visualize_learned_geometry: bool = True
    """Whether to use learned geometry in trajectory overlay visualization."""
    generate_video_predictions_throughout: bool = True
    """Whether to visualize rollout predictions in W&B gifs throughout training.
    """
    generate_video_geometries_throughout: bool = True
    """Whether to visualize learned geometry in W&B gifs throughout training."""


class DrakeExperiment(SupervisedLearningExperiment, ABC):
    base_drake_system: Optional[DrakeSystem]
    visualization_system: Optional[DrakeSystem]

    def __init__(self, config: SupervisedLearningExperimentConfig) -> None:
        super().__init__(config)
        self.base_drake_system = None

    def get_drake_system(self) -> DrakeSystem:
        has_property = hasattr(self, 'base_drake_system')
        if not has_property or self.base_drake_system is None:
            base_config = cast(DrakeSystemConfig, self.config.base_config)
            dt = self.config.data_config.dt
            self.base_drake_system = DrakeSystem(base_config.urdfs, dt)
        return self.base_drake_system

    def get_base_system(self) -> System:
        return self.get_drake_system()

    def get_learned_drake_system(
            self, learned_system: System) -> Optional[DrakeSystem]:
        r"""If possible, constructs a :py:class:`DrakeSystem` -equivalent
        model of the given learned system, such as when the learned system is a
        :py:class:`MultibodyLearnableSystem`\ .

        Args:
            learned_system: System being learned in experiment.

        Returns:
            Drake version of learned system.
        """
        return None

    def visualizer_regeneration_is_required(self) -> bool:
        """Checks if visualizer should be regenerated, e.g. if learned
        geometries have been updated and need to be pushed to the visulizer.
        """
        return False

    def get_visualization_system(self, learned_system: System) -> DrakeSystem:
        """Generate a dummy :py:class:`DrakeSystem` for visualizing comparisons
        between trajectories generated by the base system and something else,
        e.g. data.

        Implemented as a thin wrapper of
        ``vis_utils.generate_visualization_system()``, which generates a
        drake system where each model in the base
        :py:class:`DrakeSystem` has a duplicate, and visualization
        elements are repainted for visual distinction.

        Args:
            learned_system: Current trained learnable system.

        Returns:
            New :py:class:`DrakeSystem` with doubled state and repainted
            elements.
        """
        # Generate a new visualization system if it needs to use the updated
        # geometry, or if it hasn't been created yet.
        regeneration_is_required = self.visualizer_regeneration_is_required()
        if regeneration_is_required or self.visualization_system is None:
            visualization_file = file_utils.get_trajectory_video_filename(
                self.config.storage, self.config.run_name)
            base_system = self.get_drake_system()
            self.visualization_system = \
                vis_utils.generate_visualization_system(
                    base_system,
                    visualization_file,
                    learned_system=self.get_learned_drake_system(learned_system)
                )

        return self.visualization_system

    def base_and_learned_comparison_summary(
            self, statistics: Dict, learned_system: System,
            force_generate_videos: bool = False) -> SystemSummary:
        r"""Extracts a :py:class:`~dair_pll.system.SystemSummary` that compares
        the base system to the learned system.

        For Drake-based experiments, this comparison is implemented as
        overlaid videos of corresponding ground-truth and predicted
        trajectories. The nature of this video is described further in
        :py:mod:`dair_pll.vis_utils`\ .

        Additionally, manually defined trajectories are used to show the learned
        geometries.  This is particularly useful for more expressive geometry
        types like meshes.

        Args:
            statistics: Dictionary of training statistics.
            learned_system: Most updated version of learned system during
              training.
            force_generate_videos: Whether to force generate videos for
              comparison, even if the experiment's config says to skip.  This is
              useful for generating videos at the first and last epochs.

        Returns:
            Summary containing overlaid video(s).
        """
        if (not force_generate_videos) and \
            (not self.config.generate_video_predictions_throughout) and \
            (not self.config.generate_video_geometries_throughout):
            return SystemSummary(scalars={}, videos={}, meshes={})

        visualization_system = self.get_visualization_system(learned_system)

        space = self.get_drake_system().space
        videos = {}

        # First do overlay prediction videos.
        if self.config.generate_video_predictions_throughout or \
            force_generate_videos:
            for traj_num in [0]:
                for set_name in ['train', 'valid']:
                    target_key = f'{set_name}_{LEARNED_SYSTEM_NAME}' + \
                                f'_{TARGET_NAME}'
                    prediction_key = f'{set_name}_{LEARNED_SYSTEM_NAME}' + \
                                    f'_{PREDICTION_NAME}'
                    if not target_key in statistics:
                        continue
                    target_trajectory = Tensor(statistics[target_key][traj_num])
                    prediction_trajectory = Tensor(
                        statistics[prediction_key][traj_num])
                    visualization_trajectory = torch.cat(
                        (space.q(target_trajectory), space.q(prediction_trajectory),
                        space.v(target_trajectory),
                        space.v(prediction_trajectory)), -1)
                    video, framerate = vis_utils.visualize_trajectory(
                        visualization_system, visualization_trajectory)
                    videos[f'{set_name}_trajectory_prediction_{traj_num}'] = \
                        (video, framerate)

        # Second do geometry inspection videos.
        if self.config.generate_video_geometries_throughout or \
            force_generate_videos:
            geometry_inspection_traj = \
                vis_utils.get_geometry_inspection_trajectory(learned_system)
            target_trajectory = geometry_inspection_traj
            prediction_trajectory = geometry_inspection_traj
            visualization_trajectory = torch.cat(
                (space.q(target_trajectory), space.q(prediction_trajectory),
                space.v(target_trajectory), space.v(prediction_trajectory)), -1)
            video, framerate = vis_utils.visualize_trajectory(
                visualization_system, visualization_trajectory)
            videos['geometry_inspection'] = (video, framerate)

        return SystemSummary(scalars={}, videos=videos, meshes={})


class DrakeDeepLearnableExperiment(DrakeExperiment, DeepLearnableExperiment):
    pass


class DrakeMultibodyLearnableExperiment(DrakeExperiment):

    def __init__(self, config: DrakeMultibodyLearnableExperimentConfig) -> None:
        super().__init__(config)
        learnable_config = cast(MultibodyLearnableSystemConfig,
                                self.config.learnable_config)
        if learnable_config.loss == MultibodyLosses.CONTACTNETS_LOSS:
            self.loss_callback = self.contactnets_loss
        elif learnable_config.loss == MultibodyLosses.VISION_LOSS:
            # For DrakeMultibodyLearnableExperiment, cannot handle using vision
            # loss, so default to prediction.  This can get overwritten in the
            # VisionExperiment extension of this class.
            self.loss_callback = self.prediction_loss

    def get_learned_system(self, _: Tensor) -> MultibodyLearnableSystem:
        learnable_config = cast(MultibodyLearnableSystemConfig,
                                self.config.learnable_config)
        output_dir = file_utils.get_learned_urdf_dir(self.config.storage,
                                                     self.config.run_name)
        return MultibodyLearnableSystem(
            learnable_config.urdfs, self.config.data_config.dt,
            {'w_pred': self.config.learnable_config.w_pred,
             'w_comp': self.config.learnable_config.w_comp,
             'w_diss': self.config.learnable_config.w_diss,
             'w_pen': self.config.learnable_config.w_pen,
             'w_bsdf': self.config.learnable_config.w_bsdf},
            output_urdfs_dir=output_dir,
            pretrained_icnn_weights_filepath = \
                learnable_config.pretrained_icnn_weights_filepath,
            learn_inertia = learnable_config.learn_inertia
        )

    def visualizer_regeneration_is_required(self) -> bool:
        return cast(DrakeMultibodyLearnableExperimentConfig,
                    self.config).visualize_learned_geometry

    def get_learned_drake_system(
            self, learned_system: System) -> Optional[DrakeSystem]:
        if self.visualizer_regeneration_is_required():
            new_urdfs = cast(MultibodyLearnableSystem,
                             learned_system).generate_updated_urdfs()
            return DrakeSystem(new_urdfs, self.get_drake_system().dt)
        return None

    def contactnets_loss(self,
                         x_past: Tensor,
                         x_future: Tensor,
                         system: System,
                         keep_batch: bool = False) -> Tensor:
        r""" :py:data:`~dair_pll.experiment.LossCallbackCallable`
        which applies the ContactNets [1] loss to the system.

        References:
            [1] S. Pfrommer*, M. Halm*, and M. Posa. "ContactNets: Learning
            Discontinuous Contact Dynamics with Smooth, Implicit
            Representations," Conference on Robotic Learning, 2020,
            https://proceedings.mlr.press/v155/pfrommer21a.html
        """
        assert isinstance(system, MultibodyLearnableSystem), f'Expected ' + \
            f'MultibodyLearnableSystem, got {type(system)}.'
        x = x_past[..., -1, :]
        # pylint: disable=E1103
        u = torch.zeros(x.shape[:-1] + (0,))
        x_plus = x_future[..., 0, :]
        loss = system.contactnets_loss(x, u, x_plus)
        if not keep_batch:
            loss = loss.mean()
        return loss
